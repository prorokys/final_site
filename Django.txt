pip install virtualenv
virtualenv name

Windows:
name/Scripts/activate                views.py === це контролери запам'ятай Руся!!!

MacOS / Linux
source name/bin/activate

pip install django

pip install flake8

pip freeze > requirements.txt

django-admin startproject projectname

cd projectname                                      views.py === це контролери запам'ятай Руся!!!

django-admin startapp appname    

зареєструвати додатки у проекті в файлі settings.py

створити файл urls.py у додатках

для запуску серверу звертаємось у терміналі
до файлу manage.py та викликаємо команду runserver

python manage.py runserver

У додатку в файлі views.py імпортувати класс
відповіді

from django.http import HttpResponse

Створити функцію відображення обов'язково
приймає request та повертає HTtpResponse

Переходимо у файл urls.py (у додатку)

Імпортуємо функцію для генерації юрл адресс
from django.urls import path

Та функції з views цього додатку                 views.py === це контролери запам'ятай Руся!!!
from .views import *

Створюємо список urlpatterns
В якому прописуємо які функції будуть відкриватись
по певним юрл адрессам

Наприклад відкритття функції main по пустій юрл адрессі
urlpatterns = [
    path('', main, name='main')
]

<link rel="stylesheet" href="{% static 'css/styles.css' %}">
стилі CSS

динамічни urls адреси:  <a href="{% url 'main' %}">Main</a>


{{ змінні }} # так писати
{% if name_category %}
		це шаблоний тег
{% endif %}


Переходимо в файл urls.py у проекті та підключаємо
всі юрл адреси додатків за
певними шляхами наприклад

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('catalog/', include('catalog.urls', namespase='catalog')),
    path('orders/', include('orders.urls', namespase='orders'))
]

python manage.py makemigrations

python manage.py migrate 

<ModelName>.objects.create(name='_____') # созданіє моделєй бази даних




python manage.py createsuperuser   # створення
суперюзера для адмінки!!!

регістрація моделей в admin.py проєкта: 
from <name_project>.models import <ModelName>, <ModelName>

admin.site.register(ModelName)
admin.site.register(ModelName)



STATICFILES_DIRS = [BASE_DIR / 'static']


Відображення в templates HTML проєкта файлів із бази-даних 
пишем у views.py проєкта:
from <name_project>.models import <ModelName>, <ModelName>

def name_category(request):      # передаємо context у return!!!
		context = {
				'title': 'name_title',
				'name_category': <ModelName>.objects.all(),
				'name_category': <ModelName>.objects.all(),
		}
		return render(request, 'name_html.html', context)
Щоб картинки відображалися в HTML коді треба вставити: {{ name_category.image.url }}

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media/'

Для загрузки медіа (img файлів)
в urls.py  проєкта  імпортуємо:
from django.conf.urls.static import static
from django.conf import settings

под urlpatterns пишимо:
if settings.DEBUG == True:
		urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

Щоб картинки відображалися в HTML коді треба вставити: {{ name_category.image.url }}




django фікстури:    # це файл для баз даних якщо база даних зломалася!!!
python manage.py dumpdata <app_name>.<ModelName> > name_file.json
python manage.py loaddata <path_to_fixture_file>  == це для загрузки фавйлів у базу даних!!!



python manage.py startapp users == створення моделі user(пользователей) баз даних

В файлі === models.py!!!
from django.contrib.auth.models import AbstractUser

class User(AbstractUser): == новий user наследує клас AbstractUser
		image = models.ImageField(upload_to='users_ images', null=True, blank=True)
		це дабавляє потрібні поля до вже існуючих полів класа AbstractUser

python manage.py makemigrations
python manage.py migrate

Потрібно регістрація User в файлі admin.py
from users.models import User

admin.site.register(User)
======================={% url 'users:login' %}
============================= ^^^^^ =це login наслідує від users!!!==========

Якщо буде помилка треба в файлі проєкта settings.py додати:  
			AUTH_USER_MODEL = 'users.User'
		щоб переопредилити модель user(пользователя) в проекті django!!!
		
python manage.py createsuperuser   # створення суперюзера для адмінки!!!



base.html  == базовий html в якому все головне а в інщіх html файлах вставляємо 
							силку  {% extend 'name_app/base.html' %}
										{% block content %}
												<name_нужного_блока>
										{% endblock %} ==== все це у потрібном файлі html
							
							
							
{% block content(===інщіх html файлів===) %}
{% endblock %} =========== це пишем у base.html  == базовий html


views.py === це контролери запам'ятай Руся!!!


=====работа с формами регістрація і авторизація=====
===== все це робимо в папкі users ======
Приклад коду:

class UserLoginForm(AuthenticationForm):
		class Meta:
				model = User
				fields = ('username', 'password')
				
в папкі users створити файл forms.py
from django.contrib.auth.forms import AuthenticationForm
from users.models import User


class UserLoginForm(AuthenticationForm):
		class Meta:
				model = User
				fields = ['username', 'password']


далі переходим у views.py
from users.models import User
from users.forms import UserLoginForm

===Примери функцій===
def login(request):
		context = {'form': UserLoginForm(визиваємо клас!)} 
		=== создаємо ^ context ^ і передаємо Форму!!! ===
		return render(request, 'users/login.html', context)
		Потім переходимо на login.html, і <form>
		                                                            {{ form.as_p }} ===так відображаються поля
																	                         login і  registration у формі 
                                                                                             реєстрації на login.html																							 
		                                                       </form>

def registration(request):
		return render(request, 'users/registration.html')
		
============Контролер авторизації============
	audit - контроль
	authentication - підтверження подліності
	authorisation - разрешение
	





============================================
 Обработчік 404 страниця не знайдена:
 в settings.py проєкта в DEBUG = False<---<повинно стояти!
 в urls.py проєкта  пишемо:
 handler404 = page_not_found 

в приложенії в файлі views.py пишимо функцію:
def page_not_found(request, exeption):
		return HttpResponseNotFound(<h1>Page not found</h1>)
============================================	
	
Функція redirect: перенаправляє на другий url якщо 
на сторінці не було знайденно або не вірно введенно
Приклад:

def archive(request, year):
		if year > 2024:               код 301 \|/
			return redirect('/', permanent=True) --->перенаправляє на головну сторінку сайта, або
			                                    на іншу потрібну сторінку сайта
		return HTtpResponse(<h1>Архів по рокам:</h1>)

		   return redirect('home')-->краще писати ім'я сторінки які пишем 
		   в файлі  urls.py  приложенії :
            		   urlpatterns = [ path('home', views.index, name='home')]
====================================================




python manage.py shell   <-- Тепер давайте перейдемо до інтерактивної 
оболонки Python і пограємось із безкоштовним API


==================================================



python manage.py collectstatic --> Збирає всі статичні файли з усіх папок проєкта
                                                        і зберігає у спеціальній папці!  static в корні проєкта!!

щоб не слітала static при перевірки сайта без дебаг режиму на локальному комьютері
треба вести :  python manage.py runserver --insecure

==================================================

python manage.py shell_plus --print-sql  <--це  крута панель для роботи з заповнням 
                                                                    моделей  (бази даних)  даними
																	
==================================================
